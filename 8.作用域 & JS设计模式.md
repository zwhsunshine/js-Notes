### 1. 作用域
1. 作用域：
    > 在script标签中执行js的范围

2. 全局作用域
    1. window是一个最大全局作用域，只要是var或者a=20或者函数声明，默认都是window下的属性

    2. 访问私有变量的时候，如果私有域中没有，会向上查找，直到window结束，如果window都没有就报错
3. 局部作用域（函数 & 块级作用域）
    1. 函数
        1. 函数中的作用域， 函数自己是个域，它和全局预解析是一样的
    
        2. 访问私有变量的时候，如果私有域（函数内部）中没有变量或者没有函数，那么还会找参数，如果参数还没有，直接找父级域，直到全局（window），如果全局没有就报错
        3. 如果局部有var或者函数，那么会优先var和函数，没有才会找参数
        4. 如果函数内预解析之后是undefined，并且有参数，参数内还有值，那么优先实参
    2. 块级作用域
        1. 只要在块级作用域下声明变量（let），那么这个let变量是不会超出块这个范围的
    
        2. 如果声明一个函数，那么在块之外访问这个函数为undefined，在内部就是函数本身
4. 作用域链:
    1. 全局作用域是在最顶层，函数为里层，函数内如果找不到某个变量，那么会去函数的参数中查找，如果还没有会去父级找，直到全局，如果全局还找不到，那么就报错，这种关系就叫作用域链

    2. 注意：查找会从里往外找，而不会从外往里找。
5. 
    1. 如果实参传入的是一个简单类型，那么在函数内修改这个形参，那么外界是不会受到任何干扰的
    2. 如果传入的是复合类型，那么修改形参的值会影响外界的复合类型。
    3. 如果参数传入的是复合类型，函数内又赋值了一个复合类型此时是不会对外界干扰。
    ```
    //demo1
    var a = 3;
    function fn(a){
    	console.log(a);  //3
    	a = 10;
    	console.log(a);  //10
    }
    fn(a);
    console.log(a);  //3
    
    //demo2
    var a = [1,2,3,4];
    function fn(a){
    	console.log(a);  //[1,2,3,4]
    	a[1] = 6;
    	console.log(a);  //[1,6,3,4]
    }
    fn(a);
    console.log(a);  //[1,6,3,4]
    
    //demo3
    var a = [1,2,3,4];
    function fn(a){
    	console.log(a);  //[1,2,3,4]
    	a = [1,2];
    	console.log(a);  //[1,2]
    }
    fn(a);
    console.log(a);  //[1,2,3,4]
    ```
6. 只要报错，就会终止当前script标签中报错之后的代码执行。如果下面还有别的script标签，下面的标签正常运行。

### 2. 带var不带var的区别
1. 共同点：当赋值之后变量名都是window下的一个属性。
2. 如果没有var或者let..的申明，不赋值就报错

### 3. 预解析
1. 先找var 和 函数
    1. 如果函数和变量的名字一样，那么只留下了函数
    2. 如果多个函数的名字一样，那么会留下最后一个

2. 逐行解读代码
    1. 看等号，如果有赋值，这个变量就是被赋值的值
    2. 就算下面有函数声明也不会继续看了，因为已经预解析过了，只有在调用的时候才会进入函数体内运行代码

        ```
        console.log(a); //function(){}
    	console.log(b); //undefined
    	var a = 10;
    	var b = 5;
    	console.log(a); //10
    	console.log(b); //5
    	function a(){
    		console.log(10);
    	}
    	function c(){
    		console.log(20);
    	}
    	c();  //20
    	a();  //报错:a is not a function
        ```
### 4. 动态数组和静态数组的区别
1. 静态数组在编译时必须知道其长度即需用常量表达式指定数组长度，数组只在定义它的块语句内存在。

2. 动态数组在运行时动态地分配数组。虽然数组长度是固定的，但动态分配的数组不必在编译时知道其长度，可以（通常也是）在运行时才确定数组长度。与数组变量不同，动态分配的数组将一直存在，直到程序显式释放它为止。

3. 同理：获取元素也分为获取静态元素和动态元素。
    1. query选择符选出来的元素及元素数组是静态的。

    2. getElement这种方法选出的元素是动态的。动态就是选出的元素会随文档改变，静态的不会，取出来之后就和文档的改变无关了。
    3. 在使用的时候getElement这种方法性能比较好，query选择符则比较方便．
4. 获取动态元素：
    ```
    getElementsByTagName
    children
    getByclassName
    ```
5. 获取静态元素
    ```
    querySelector
    querySelectorAll
    ```
### 5. DOM的操作是剪切还是复制？是剪切
1. appendChild：如果页面中有相应的元素，此时是剪切。如果页面中没有，则是添加
    ```
    <ul id="ul">
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>
    
    //demo1
    <script>
    let li = document.getElementsByTagName('li');
    for(let i=0; i<li.length ;i++){
        ul.appendChild(li[i]);
    }
    </script>
    //最后li的排序为 24153
    
    /*
        初始排序：  12345
        循环当i=0   23451
              i=1   24513
              i=2   24135
              i=3   24153
              i=4   24153
        是因为获取元素时用的getElementsByTagName，所以元素的顺序是动态的，会发生变化的
    */
    
    //demo2
    <script>
    let li = document.querySelectorAll('li');
    for(let i=0; i<li.length ;i++){
        ul.appendChild(li[i]);
    }
    </script>
    //最后li的排序为 12345
    
    /*
        初始排序：  12345
        循环当i=0   23451
              i=1   34512
              i=2   45123
              i=3   51234
              i=4   12345
        是因为获取元素时用的querySelectorAll，所以元素的顺序是静态的，不会发生变化
    */
    ```

### 6. 定时器
1. setTimeout(fn,time,第一个函数的参数);
2. setInterval(fn,time,第一个函数的参数);
3. 返回值为数字: 代表有多少个定时器

### 7. 倒计时
1. 原理：
    1. 未来时间 - 现在时间 = 还剩下时间（得到的是ms，需要换算成s）
    2. 用这个结果，去计算出 日、时、分、秒

2. 公式：
    ```
    let date = new Date('2018 10 25 10'); //设置未来时间
    let nowdate = new Date;  //获取现在时间
    let d = (date - nowdate) / 1000; //计算出剩余时间并换算成秒
    
    //公式1
    let dd = Math.floor( d/86400 ); //天
    let h = Math.floor( d%86400/3600 ); //时
    let m = Math.floor( d%86400%3600/60 ); //分
    let s = Math.floor( d%60 ); //秒
    
    //公式2
    let dd = Math.floor( d/86400 ); //天
    d %= 86400;
    let h = Math.floor( d/3600 ); //时
    d %= 3600;
    let m = Math.floor( d/60 ); //分
    d %= 60;  //秒（需要加上Math.floor()）
    ```
### 8. 防止重命名
1. 封闭空间：匿名函数自执行,函数内是一个独立的作用域，函数中的作用域是不会和父级的作用域打架，各是各的

2. 命名空间：把变量变成对象下的属性

### 9. 闭包
1. 在js中，当函数套函数，子函数使用了父函数的参数或者变量，并且外部一直在使用这个函数的返回值，此时父函数的参数和变量，是不会被浏览器垃圾回收机制立马回收，这个时候父级形成闭包环境

2. 函数就是一个闭包
3. 函数内部的参数或者变量被外界访问，此时形成闭包环境
    ```
    //demo
    function fn(){
        var a = 20; 
        return function (){
            a ++;
            console.log(a);
        }
    }
    let f = fn();
    f(); //21
    f(); //22
    ```
### 10. JS设计模式
1. 单例模式(单独的实例):
    1. 把描述同一个东西的不同属性归纳在一起，用对象管理的模式。

    2. 单例模式它限制了类的实例化次数只能一次。在实例不存在的情况下，可以通过一个方法创建一个类来实现创建类的新实例；如果实例已经存在，它会简单返回该对象的引用。（这跟我想的一样）
    3. 单例不同于静态类（或对象），因为我们可以推迟它们的初始化（通常是因为它们需要的参数信息在类定义时是无法获得的），直到需要使用静态实例时，无需使用资源或内存。
    4. 单例的唯一实例能够通过子类去扩展，使用者不用更改代码就能使用一个扩展的实例。
    5. 单例将导致测试变困难，不利于单元测试。
    6. 何时使用单例:
        1. 是否每个应用程序使用这个类的方式都完全相同？
        
        2. 是否每个应用程序任何时候都只需要一个类的实例？
        3. 使用者不需要知道该类是这应用程序的哪个部分？（或许翻译不好）
        4. 当满足这三个点，那就可以用单例。关键就在于类的使用方式都相同，并且不需要应用上下文。

2. 高级单例模式:
    1. 在给命名空间赋值的时候，不是直接赋值一个对象，而是先执行匿名函数，形成一个私有作用域AA（不销毁的栈内存），在AA中创建一个堆内存，把堆内存地址赋值给命名空间
    
    2.这种模式的好处：我们完全可以在AA中创造很多内容（变量OR函数），哪些需要供外面调取使用的，我们暴露到返回的对象中（模块化实现的一种思想）
3. 工厂模式（Factory Pattern）
    1. 把实现相同功能的代码进行“封装”，以此来实现“批量生产”（后期想要实现这个功能，我们只需要执行函数即可）

    2. “高内聚低耦合”：减少页面中的冗余代码，提高代码的重复使用率
    3. 何时使用工厂：
        1. 当对象或组件设置非常复杂的时候。
        
        2. 当需要根据所在的不同环境轻松生成对象的不同实例时。
        3. 当处理很多共享相同属性的小型对象或组件时。
        4. 对象的实例只需要满足一个约定——鸭子类型(duck typing)。利于解耦。
        5. PS：鸭子类型——“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。
4. 模块化开发
    1. 团队协作开发的时候，会把产品按照功能板块进行划分，每一个功能板块有专人负责开发
    2. 把各个版块之间公用的部门进行提取封装，后期在想实现这些功能，直接的调取引用即可（模块封装）
    3. 高内聚、低耦合

### 11. this
1. 全局：window
2. 单纯函数调用：window
3. 定时器中：window
4. 方法中：方法前面.前面的主是谁，this就是谁
5. 事件中：事件触发谁，this就是谁
6. 严格模式下：this是undefined
    ```
    'use strict'
    ```
7. 构造函数&构造函数的原型下：this是实例化对象

### 12. call & apply & bind
1. call(this,实参1,实参2,实参3...);

2. apply(this,数组);
3. bind(this,实参1,实参2,实参3...);
4. 共同点：改变this指向
5. 区别：
    1. call()、apply()会自动执行函数
    2. bind()，返回值是函数体，不会自动执行函数，需要手动执行




